# ZkToken — Smart Contracts (Foundry)

Solidity contracts for the ZkToken shielded pool on Avalanche C-Chain.
Built with [Foundry](https://book.getfoundry.sh/).

---

## Contract Architecture

```
contracts/
├── src/
│   ├── ShieldedPool.sol              # Core pool — deposit, transfer, withdraw
│   ├── IncrementalMerkleTree.sol     # Append-only Poseidon Merkle tree (depth 20)
│   ├── PoseidonT3.sol                # On-chain Poseidon hash (2-input, for Merkle nodes)
│   ├── Groth16VerifierTransfer.sol   # Auto-generated verifier for the transfer circuit
│   ├── Groth16VerifierWithdraw.sol   # Auto-generated verifier for the withdraw circuit
│   └── interfaces/
│       └── IVerifier.sol             # Shared Groth16 verifier interface
├── script/
│   └── Deploy.s.sol                  # forge script — deploys verifiers + ShieldedPool
├── test/
│   ├── ShieldedPool.t.sol            # Unit + integration tests for the pool
│   └── MerkleTree.t.sol              # Unit tests for the incremental Merkle tree
├── lib/
│   └── forge-std/                    # Foundry standard library
└── foundry.toml                      # Foundry project config
```

---

## Contracts

### `ShieldedPool.sol`

Core shielded pool contract. Wraps any ERC20 token with a privacy layer using
Groth16 zero-knowledge proofs and a Poseidon incremental Merkle tree.

**Architecture — Option A (in-circuit Pedersen balance check):**
Pedersen commitment coordinates are entirely private signals — they never appear
as public inputs or in calldata. The ZK circuit verifies `C_in == C_out_1 + C_out_2`
via `BabyAdd` internally. The contract only sees 4 public outputs per circuit.

**State:**
| Storage | Type | Description |
|---|---|---|
| `nullifiers` | `mapping(uint256 => bool)` | Spent nullifier registry |
| `knownRoots` | Circular buffer (30 roots) | Historical Merkle roots for stale-proof tolerance |
| `nextLeafIndex` | `uint256` | Current tree size |
| `filledSubtrees` | `uint256[20]` | Merkle tree intermediate subtree hashes |
| `currentRoot` | `uint256` | Latest Merkle root |

**Function signatures:**

```solidity
/// Lock ERC20 tokens and insert a note commitment into the Merkle tree.
function deposit(uint256 amount, uint256 commitment) external;

/// Consume an input note (via nullifier) and create two output notes.
/// proof encodes [proof_a, proof_b, proof_c] packed as bytes.
/// Public inputs: merkleRoot, nullifierHash, newCommitment1, newCommitment2
function transfer(
    bytes calldata proof,
    uint256 merkleRoot,
    uint256 nullifierHash,
    uint256 newCommitment1,
    uint256 newCommitment2,
    bytes calldata encryptedMemo1,
    bytes calldata encryptedMemo2
) external;

/// Consume an input note, release ERC20 to recipient, insert change commitment.
/// Public inputs: merkleRoot, nullifierHash, amount, changeCommitment
function withdraw(
    bytes calldata proof,
    uint256 merkleRoot,
    uint256 nullifierHash,
    uint256 amount,
    uint256 changeCommitment,
    address recipient,
    bytes calldata encryptedMemo
) external;
```

**Events:**
```solidity
event Deposit(uint256 indexed commitment, uint32 leafIndex, uint256 timestamp);
event PrivateTransfer(uint256 nullifierHash, uint256 commitment1, uint256 commitment2, bytes encryptedMemo1, bytes encryptedMemo2);
event Withdrawal(uint256 nullifierHash, address indexed recipient, uint256 amount, uint256 changeCommitment);
```

---

### `IncrementalMerkleTree.sol`

Append-only Merkle tree using Poseidon(2) for internal node hashing.

- **Depth:** 20 (supports up to 1,048,576 commitments)
- **Zero values:** `zero[0] = 0`, `zero[i] = Poseidon(zero[i-1], zero[i-1])`
- **Root history:** circular buffer of last 30 roots (stale proofs remain valid)
- **Insertion cost:** O(depth) — updates only the filled subtrees along the rightmost path

---

### `PoseidonT3.sol`

On-chain Poseidon hash for 2 inputs (t=3). Must use **identical parameters** to the
Circom circuit Poseidon: 8 full rounds, 57 partial rounds, x^5 S-box, BN254 scalar field.

Generated from `circomlibjs` / `poseidon-solidity` to guarantee parameter parity.

---

### `Groth16VerifierTransfer.sol` / `Groth16VerifierWithdraw.sol`

Auto-generated by snarkjs from the trusted setup zkeys:
```bash
# From project root:
bash scripts/generate_verifier.sh
```

Both implement `IVerifier` with 4 public inputs:

| Circuit | Public inputs (in order) |
|---|---|
| Transfer | `merkle_root`, `nullifier_hash`, `new_commitment_1`, `new_commitment_2` |
| Withdraw | `merkle_root`, `nullifier_hash`, `amount`, `change_commitment` |

---

### `IVerifier.sol`

```solidity
interface IVerifier {
    function verifyProof(
        uint[2] calldata _pA,
        uint[2][2] calldata _pB,
        uint[2] calldata _pC,
        uint[4] calldata _pubSignals
    ) external view returns (bool);
}
```

---

## Quick Start

```bash
cd contracts

# Build
forge build

# Test
forge test
forge test -vvv        # verbose with traces
forge test --gas-report

# Format
forge fmt

# Local node
anvil
```

---

## Deployment

### Environment

```bash
# .env (never commit)
DEPLOYER_PRIVATE_KEY=0x...
SNOWTRACE_API_KEY=...
```

### Deploy to Fuji Testnet (Chain ID 43113)

```bash
forge script script/Deploy.s.sol \
  --rpc-url https://api.avax-test.network/ext/bc/C/rpc \
  --private-key $DEPLOYER_PRIVATE_KEY \
  --broadcast \
  --verify
```

### Deploy to Avalanche Mainnet (Chain ID 43114)

```bash
forge script script/Deploy.s.sol \
  --rpc-url https://api.avax.network/ext/bc/C/rpc \
  --private-key $DEPLOYER_PRIVATE_KEY \
  --broadcast \
  --verify
```

Explorers: [Snowtrace Mainnet](https://snowtrace.io) · [Snowtrace Fuji](https://testnet.snowtrace.io)

---

## Gas Estimates (Avalanche C-Chain @ 25 nAVAX)

| Operation | Est. Gas | ~USD (AVAX $35) |
|---|---|---|
| `deposit` | ~280,000 | ~$0.24 |
| `transfer` | ~480,000 | ~$0.42 |
| `withdraw` | ~380,000 | ~$0.33 |

> Groth16 proof verification on BN254 costs ~200k gas via pairing precompiles (0x07, 0x08).

---

## Security Notes

- **Poseidon parity:** On-chain Poseidon must use **identical** round constants to the Circom circuits. Any mismatch causes all proofs to fail silently.
- **Root history:** Proofs are accepted against any of the last 30 known roots. Proofs older than 30 insertions become invalid.
- **Nullifier finality:** Once a nullifier is stored, the corresponding note is permanently spent. There is no undo.
- **Single contributor ceremony:** The current zkeys were generated with one contributor (dev setup). For mainnet, run a multi-party ceremony — see `scripts/setup_ceremony.sh`.
